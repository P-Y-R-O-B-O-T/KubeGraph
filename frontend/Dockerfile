# Dockerfile

# -----------------------------------------------------------------------------
# Builder Stage: Build the Next.js app
# -----------------------------------------------------------------------------
FROM node:22-alpine AS builder

ARG NEXT_PUBLIC_BACKEND_API_URL_ARG

# Set working directory
WORKDIR /app


# Set environment variables for the build
# ENV NODE_ENV=production # <-- IMPORTANT: REMOVED/COMMENTED OUT. devDependencies are needed for build.

# Disable Next.js telemetry during the build
ENV NEXT_PUBLIC_BACKEND_API_URL=$NEXT_PUBLIC_BACKEND_API_URL_ARG
ENV NEXT_TELEMETRY_DISABLED=1

# Copy package.json and lock files
# Using '*' for lock files to be flexible (yarn.lock, package-lock.json, pnpm-lock.yaml)
COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./

# Install dependencies based on the detected lock file
# npm ci is generally preferred if package-lock.json exists for faster, more reliable builds.
# devDependencies (like tailwindcss, postcss) WILL be installed now.
RUN if [ -f package-lock.json ]; then npm ci; \
    elif [ -f yarn.lock ]; then yarn install --frozen-lockfile; \
    elif [ -f pnpm-lock.yaml ]; then \
      # Install pnpm if using pnpm-lock.yaml
      # Check if corepack is available (common in Node 16.9+), enable it, and use it to prepare pnpm
      if command -v corepack &> /dev/null; then \
        corepack enable && corepack prepare pnpm@latest --activate; \
      else \
        # Fallback for older Node versions or environments without corepack
        npm install -g pnpm; \
      fi && \
      pnpm install --frozen-lockfile; \
    else echo "Lockfile not found. Please check your project setup." && exit 1; \
    fi

# Copy the rest of the application source code
# This includes tsconfig.json, next.config.js, src/, public/, etc.
COPY . .


RUN echo "BUILD_DEBUG: NEXT_PUBLIC_BACKEND_API_URL is set to '$NEXT_PUBLIC_BACKEND_API_URL'"

# Build the Next.js application
# The build script should be defined in your package.json (e.g., "build": "next build")
# next build automatically creates a production-optimized build
RUN npm run build
# If you use pnpm, you might have: RUN pnpm run build
# If you use yarn, you might have: RUN yarn build

# -----------------------------------------------------------------------------
# Runner Stage: Serve the production Next.js app
# -----------------------------------------------------------------------------
FROM node:22-alpine AS runner

WORKDIR /app

# Set environment variables for the runtime
ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1
ENV HOSTNAME="0.0.0.0"
# The PORT environment variable will be automatically set by Cloud Run.
# Your package.json start script should use it, e.g., "start": "next start -p $PORT"

# Create a non-root user and group for better security
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# Copy the standalone output from the builder stage.
# This assumes you have `output: 'standalone'` in your next.config.js.
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./

# Copy the public folder from the builder stage.
COPY --from=builder --chown=nextjs:nodejs /app/public ./public

# Copy the static assets folder from the builder stage.
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

# Switch to the non-root user
USER nextjs

# Expose the port the app will run on.
# Next.js default is 3000. Cloud Run will map its $PORT to this.
EXPOSE 3000

# The command to start the Next.js application in production mode.
# This relies on the "server.js" file generated by the standalone output.
CMD ["node", "server.js"]